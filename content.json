{"meta":{"title":"Hexo博客","subtitle":"","description":"","author":"Yonggang Shi","url":"http://blog.loveyx815.cn","root":"/"},"pages":[{"title":"","date":"2020-04-19T07:22:46.538Z","updated":"2020-04-08T02:55:48.126Z","comments":false,"path":"tags/index.html","permalink":"http://blog.loveyx815.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-19T07:22:46.535Z","updated":"2020-04-08T02:56:22.242Z","comments":false,"path":"categories/index.html","permalink":"http://blog.loveyx815.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发","slug":"summary/并发/Java并发","date":"2020-04-23T16:00:00.000Z","updated":"2020-04-28T09:26:58.430Z","comments":true,"path":"2020/04/24/summary/并发/Java并发/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/24/summary/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91/","excerpt":"","text":"Java并发一、基础概念线程和进程的区别： 进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。 一个进程可以拥有多个线程组合，线程是组成进程的基本单位。 线程状态 New(新创建) Runnable（可运行） Blocked(被阻塞) Waiting(等待) Time waiting(计时等待) Terminated(被终止) 下面介绍线程状态的含义： 新创建线程 用new创建个新线程时，他还未开始运行，表示这还处于新创建的状态。 可运行线程 一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行。 被阻塞线程和等待线程 当线程处于被等待或者阻塞状态时，暂时不活动，他不运行任何代码，并且只会消耗最小的资源，直到线程调度器重新激活它。 被终止的线程 线程因为run方法执行完毕而自然死亡、因为一个未捕获的异常终止了run方法而意外死亡 线程运行状态图 线程属性 优先级 默认情况下，一个线程继承他父线程的优先级。每当线程调度器有机会选择新线程时，他首先选择具有较高优先级的线程。 1234//设置线程的优先级，大小一般1-10void setPriority(int newPriority)//当前线程处于让步状态，会调度其他优先级&gt;=当前优先级的线程static void yield() 守护线程 void setDaemon(boolean isDaemon)通过该方法转换成守护线程，守护线程必须在线程启动之前调用。用途就是为其他线程提供服务，当只有守护线程的时候JVM就直接退出了。 同步 锁 ReentrantLock: 用可重入锁保护代码块 123456789Lock mylock = new ReentrantLock();mylock.lock();try&#123; ...&#125;finally&#123; //保证资源一定会解锁 mylock.unlock();&#125; 条件对象： 需要线程安全区域可能还需要一定的条件支持。若一个线程在获得锁之后，一直在等待条件满足才能完成自己的线程，而使条件发生改变的线程正在等待获得锁。那么此时就就产生死锁。 也就是两个线程互相依赖对方资源。 解决方案： 先来了解下Condition 123456789Condition newCondition()//返回一个与该锁相关的条件对象//对条件对象的操作void await() //将该线程放到条件的等待集合中void signalAll()//解除该条件的等待集合中的所有线程的阻塞状态void signal()//从该条件的等待集合中随机选择一个线程，解除其阻塞状态 Synchronized 锁和条件： 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码 锁可以管理视图进入被保护代码段的线程 锁可以拥有一个或多个相关条件对象 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程 12345678910//以下如果当前对象没有获得该锁，会抛出异常void notifyAll()//解除那些在改对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步代码块中调用。void notify()//与上面的不同的是，这个这能随机选择一个线程解除其阻塞状态void wait()//让该线程进入等待状态直到他被通知void wait(long millis)//指定等待多少毫秒 Volatile： volatile关键字为实例域的同步访问提供了一共免锁机制。如果声明一个域为volatile，编译器和JVM就知道该域是可能被另一个线程并发更新的。对volatile域变量更新是所有线程共享的域，还可以防止指令重排。 Volatile变量不能提供原子性，在语句执行的过程中不能保证读取、写入不被中断，不能确保线程安全。 final： 除了volatile和锁之外能安全的读取一个域，final关键字修饰的域也可以。 读写锁 ReentrantReadWriteLock适合读多写少的并发 1234//得到一个可以被多个读操作公用的读锁，会排斥所有的写操作Lock readLock()//得到一个写锁，排斥所有的读、写操作Lock writeLock() 如何使用： 123456789101112131415161718192021 //新建个读写锁对象 ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(); //获取读锁 Lock readLock = reentrantReadWriteLock.readLock(); //获取写锁 Lock writeLock = reentrantReadWriteLock.writeLock();//读操作readLock.lock(); try&#123; ... &#125;finally&#123; readLock.unlock(); &#125;//写操作writeLock.lock(); try&#123; ... &#125;finally&#123; writeLock.unlock(); &#125; -","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://blog.loveyx815.cn/tags/JUC/"},{"name":"并发","slug":"并发","permalink":"http://blog.loveyx815.cn/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java泛型设计","slug":"summary/Java泛型设计","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-23T10:53:20.447Z","comments":true,"path":"2020/04/21/summary/Java泛型设计/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/21/summary/Java%E6%B3%9B%E5%9E%8B%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Java泛型设计 为什么要去设计泛型？ 为了可以编写被很多不同类型对象所重用的代码 泛型是如何定义？ 1. 泛型类： class ClassNameT是一个类型变量，可以是任意的类型，也可以有多个类型比变量。 类型变量使用大写形式，使用E表示集合的元素类型，K和V分别表示关键字和值得类型，是一个Map关系。T（需要时还可以用临近的字母U和S）表示任意类型 2. 泛型方法： T function(T a)类型变量放在修饰符的后面，返回类型的前面 若方法的类型参数是个可变的参数T…a,若传入的参数类型不统一就会抛出异常 3. 类型变量的限定如果要实现个泛型的比较方法，得调用compareTo方法比较，而使用该方法得对象要实现Compareable接口。此时需要在泛型方法中增加一个限定项，只允许传入实现了Compareable接口的类。 修改后限定泛型的方法签名： 1&lt;T extends Compareable&gt; T function(T a) 通用的写法是 ，表示T是绑定类型的子类型，绑定类型可以是接口或者类。绑定类型也可以是多个类型，用&amp;分隔 4. 约束与局限性 不能用基本类型实例化类型参数 不能用基本类型参数去代替基本类型。因为泛型使用过程会有类型擦除。擦除后就变成Object类型，而基本类型又不能存储到Object中。可以使用包装类型。 判断对象是否属于定义的泛型类型 现有泛型类 Pair&lt;T&gt; 123class Pari&lt;T&gt;&#123; ...&#125; 判断对象a是否是该泛型类任一类型： 12345if (a instanceof Pair&lt;String&gt;) //errorif (a instanceof Pair&lt;T&gt;) //errorPair&lt;String&gt; p = (Pair&lt;String&gt;)a //error//正确的操作是判断对象的Class类型a.getClass()//返回的就是Pair.class 同时也不能创建参数化类型的数组 12//不能实例化参数化类型的数组Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10];//error 在类型擦除的时候，table的类型是Pair[]，就算用Object[]来接收，table还是会记住他的原始类型Pari[]，如果将其他对象放入table中，还是会有类型错误 12Object[] table = new Pair&lt;String&gt;[10];table[0]=\"string\";//error 不能实例化类型变量 不能使用像new T( ),new T[ ],T.class这样的表达式中的类型变量 12345//构造器错误public Pair() &#123; first = new T(); second = new T();&#125; 正确的是提供个构造器表达式 12345Pair&lt;String&gt; p = Pair.makePair(String.class);//makePair构造器调用，通过反射 newInstance()public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123; return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance())&#125;","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}]},{"title":"Mybatis在SpringBoot中的相关配置","slug":"summary/Mybatis在SpringBoot中的相关配置","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-21T13:35:02.811Z","comments":true,"path":"2020/04/21/summary/Mybatis在SpringBoot中的相关配置/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/21/summary/Mybatis%E5%9C%A8SpringBoot%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Mybatis在SpringBoot中的相关配置在DAO层采取一些配置化、插件的方式去开发，通过mybatis配置xml去引入 新建一个mybatis-config.xml文件，放入resource文件夹下面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"3000\"/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;!--驼峰命名设置，会把从数据库里查出的A_COLUMN，转换成aColumn--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\"/&gt; &lt;!-- 设置控制台打印sql --&gt; &lt;!--&lt;setting name=\"logImpl\" value=\"stdout_logging\" /&gt;--&gt; &lt;/settings&gt; &lt;!-- Continue going here --&gt; &lt;!--&lt;typeAliases&gt;--&gt; &lt;!--&lt;package name=\"cn.com.countrygarden.ucenter.entity\"/&gt;--&gt; &lt;!--&lt;/typeAliases&gt;--&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;!-- 4.0.0以后版本可以不设置该参数 --&gt; &lt;property name=\"dialect\" value=\"mysql\"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name=\"pageSizeZero\" value=\"true\"/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name=\"reasonable\" value=\"false\"/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 --&gt; &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt; &lt;!--&lt;property name=\"params\" value=\"pageNum=pageHelperStart;pageSize=pageHelperRows;\"/&gt;--&gt; &lt;!-- 支持通过Mapper接口参数来传递分页参数 --&gt; &lt;property name=\"supportMethodsArguments\" value=\"false\"/&gt; &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt; &lt;property name=\"returnPageInfo\" value=\"none\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--&lt;mappers&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;&lt;package name=\"cn.com.countrygarden.ucenter.mapper\" /&gt;&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/DiaryMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/EmpEvaluateMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/EmployeeMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/LikesMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/PicMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/RepliesMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/TeamMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"mappers/UserMapper.xml\"/&gt;--&gt; &lt;!--&lt;/mappers&gt;--&gt;&lt;/configuration&gt; 在application.properties中设置引用该配置文件 1mybatis.config-location=classpath:mybatis-config.xml","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"框架系列","slug":"Java开发总结/框架系列","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.loveyx815.cn/tags/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://blog.loveyx815.cn/tags/Mybatis/"}]},{"title":"设计模式-工厂模式","slug":"summary/设计模式-工厂模式","date":"2020-04-20T16:00:00.000Z","updated":"2020-04-23T06:43:49.803Z","comments":true,"path":"2020/04/21/summary/设计模式-工厂模式/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/21/summary/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式-工厂模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"summary/Git命令大全","slug":"summary/Git命令大全","date":"2020-04-19T07:42:49.025Z","updated":"2020-02-04T08:15:00.379Z","comments":true,"path":"2020/04/19/summary/Git命令大全/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"Git命令大全git config配置 Git 的相关参数。 Git 一共有3个配置文件： \\1. 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。 \\2. 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\\Users\\&lt;用户名&gt;\\.gitconfig。 \\3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。 123456789101112131415161718192021222324252627282930313233343536373839404142# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper 'cache --timeout=&lt;缓存时间&gt;'# 配置长期存储密码$ git config --global credential.helper store git clone从远程仓库克隆一个版本库到本地。 12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt; git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。 12# 初始化本地仓库，在当前目录下生成 .git 文件夹$ git init git status查看本地仓库的状态。 1234567# 查看本地仓库的状态$ git status# 以简短模式查看本地仓库的状态# 会显示两列，第一列是文件的状态，第二列是对应的文件# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中$ git status -s git remote操作远程库。 123456789101112131415161718# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt; git branch操作 Git 的分支命令。 1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 \"*\" 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 \"*\" 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt; git checkout检出命令，用于创建、切换分支等。 123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 \"git branch\" 和 \"git checkout\" 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt; git cherry-pick把已经提交的记录合并到当前分支。 12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt; git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。 1234567891011121314# 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;] git commit将暂存区中的文件提交到本地仓库中。 123456789101112# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m \"&lt;提交的描述信息&gt;\"# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 \"git add -u\"$ git commit -a -m \"&lt;提交的描述信息&gt;\"# 修改上次提交的描述信息$ git commit --amend git fetch从远程仓库获取最新的版本到本地的 tmp 分支上。 12345# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; git merge合并分支。 12# 把指定的分支合并到当前所在的分支下$ git merge &lt;分支名称&gt; git diff比较版本之间的差异。 123456789101112131415161718# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt; git pull从远程仓库获取最新版本并合并到本地。 首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。 12# 从远程仓库获取最新版本。$ git pull git push把本地仓库的提交推送到远程仓库。 123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt; git log显示提交的记录。 12345678# 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt; git reset还原提交记录。 12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 \"git add\" 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 \"git reset --mixed\" 命令后又做了一次 \"git add\"$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt; git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。 12# 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt; git tag操作标签的命令。 1234567891011121314151617181920212223# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tags git mv重命名文件或者文件夹。 12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt; git rm删除文件或者文件夹。 12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cached Git操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除： 123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin","categories":[],"tags":[]},{"title":"maven项目pom.xml报错","slug":"maven项目pom.xml报错","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T11:09:08.835Z","comments":true,"path":"2020/04/19/maven项目pom.xml报错/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/maven%E9%A1%B9%E7%9B%AEpom.xml%E6%8A%A5%E9%94%99/","excerpt":"","text":"maven项目pom.xml报错 expected START_TAG or END_TAG not TEXT (position: TEXT seen …\\ua0\\r\\n &lt;d… @60:11) less… (Ctrl+F1)Inspection info: Inspects a Maven model for resolution problems. 这种就是从别的地方复制粘贴的dependency时候有空格存在，导致文件识别不了，用IDE查找下空格的位置，删除就可以解决","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"maven","slug":"maven","permalink":"http://blog.loveyx815.cn/tags/maven/"}]},{"title":"Docker从入坑到放弃","slug":"Docker从入坑到放弃","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T11:09:11.109Z","comments":true,"path":"2020/04/19/Docker从入坑到放弃/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/Docker%E4%BB%8E%E5%85%A5%E5%9D%91%E5%88%B0%E6%94%BE%E5%BC%83/","excerpt":"","text":"Docker从入坑到放弃 环境安装问题 windows7安装docker异常 ：looks like something went wrong in step ‘looking for vboxmanage.exe’ 解决方案：从安装目录的 start.sh脚本开始排查，很大可能是因为电脑的环境变量没有创建成功，所以需要把脚本对应的变量打印出来看看。 打印语句：echo “$VBOX_MSI_INSTALL_PATH”#“变量名称”read param 在这里插入图片描述 **异常信息显示是‘looking for vboxmanage.exe’ ，所以 主要在这里排查，完善对应的变量名（这里已经是替换过的全命名路径了）** 保存脚本后，在运行启动快捷方式 在这里插入图片描述 运行成功","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/tags/Docker/"}]},{"title":"Springboot中Redis学习（事务、Lua、跨域）","slug":"Springboot中Redis学习（事务、Lua、跨域）","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T11:09:04.356Z","comments":true,"path":"2020/04/19/Springboot中Redis学习（事务、Lua、跨域）/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/Springboot%E4%B8%ADRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81Lua%E3%80%81%E8%B7%A8%E5%9F%9F%EF%BC%89/","excerpt":"","text":"Redis事务Lua脚本 Lua脚本在Redis中具备原子性，可以保证数据一致性的高并发环境。 Spring中提供了RedisScript接口，DefaultRedisScript为他的实现类 RedisScript接口：12345678public interface RedisScript&lt;T&gt; &#123; //获得脚本的sha1 String getSha1(); //获取脚本的返回值 Class&lt;T&gt; getResultType(); //获取脚本的字符串 String getScriptAsString();&#125; 缓存注解应用1234567//获取ID，取参数ID缓存用户 @Override @Transactional @Cacheable(value = \" redisCache\",key = \"'redis_user_'+#id\") public User getUser(long id) &#123; return dao.getUser(id); &#125; @Cacheable 注解会先尝试从指定缓存中取值 12345678//插入用户，mybatis会回填ID，取结果ID缓存用户 @Override @Transactional @CachePut(value = \" redisCache\",key = \"'redis_user_'+#result.id\") public User insertUser(User user) &#123; dao.insertUser(user); return user; &#125; @CachePut 注解会把返回的结果放入缓存中注 AOP基于动态代理，这里同类内部调用方法，不会使注解生效 springboot中解决跨域问题 1@CrossOrigin(origins = &#123;\"对方的域名\", \"null\"&#125;) 将该注解加在对用的controller的类或者方法上就可以完成对跨域的访问代码Git地址https://github.com/rainandsunshine/springboot_reomte.git","categories":[{"name":"Redis,分布式","slug":"Redis-分布式","permalink":"http://blog.loveyx815.cn/categories/Redis-%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.loveyx815.cn/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.loveyx815.cn/tags/Redis/"}]},{"title":"String、StringBuilder做为实参在方法中修改字符串值的问题","slug":"String、StringBuilder做为实参在方法中修改字符串值的问题","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T11:09:06.526Z","comments":true,"path":"2020/04/19/String、StringBuilder做为实参在方法中修改字符串值的问题/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/String%E3%80%81StringBuilder%E5%81%9A%E4%B8%BA%E5%AE%9E%E5%8F%82%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"String、StringBuilder做为实参在方法中修改字符串值的问题 场景介绍：需要在一个方法中同时修改两个字符串的值，因为不想传回一个数组，所以就尝试下直接修改字符串对象（地址引用） 下面介绍下几种修改方式： 12345678public static void changeString(String originStr)&#123; originStr=new String(\"str1 change\"); &#125; main()&#123; String str1=\"I am str1\"; changeString(str1); System.out.println(str1);//输出I am str1 &#125; 12345678public static void changeString(String originStr)&#123; originStr=\"str2 change\"; &#125; main()&#123; String str2=\"I am str2\"; changeString(str2); System.out.println(str2);//输出I am str2 &#125; 上面两种方式是直接传一个String对象，第一个是直接让形参指向新的对象，结果是方法内改变的值不是影响到实参；第二个是让形参指向一个字符串常量，结果同第一种是一样的。 因为在Java中，参数传递分为两种。一个是基本类型的值引用，这个就不多说了；还有个就是对象引用，而对象引用实际上是把存储在JVM栈区的对象引用的数据拷贝了一份。所以当你在方法内部将该对象拷贝的引用重新指向新的地址对实参是没有影响的。 这是引用拷贝时的示意图 在这里插入图片描述 接着拷贝后的originStr指向新的对象 在这里插入图片描述 可见str1的引用都没有改变，所以这样是不能改变String对象的。 接下来说所第二种为什么也不行，也就是在方法内部不重新为对象引用指向新的对象地址，而是直接给字符串赋值。先来看看String内部是怎么得构造的。 123456789101112public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ......&#125; String类是一个被final类，也就是它是不能被继承和更改的。里面用一个char数组维护他的字符，所以我们使用的字符串都是里面的char数组转化而来，而这个char[] value也是被final修饰过的。所以String对象具有不能被修改的属性。如下图： 在这里插入图片描述 即使你在方法内部使用的将一个String对象拷贝引用originStr指向一个字符串常量”new str1”，他也是拷贝引用去指向字符串常量池中某一块地址，所以依旧还是不能影响到实参的字符串对象值。 最后是使用了StringBuilder作为参数，在方法内部修改StringBuilder引用指向内存的数据，实现在方法中直接修改字符串的值。12345678public static void changeString(StringBuilder originStr)&#123; originStr.replace(0,originStr.length(),\"str1 change\");&#125; main()&#123;StringBuilder sb1=new StringBuilder(\"I am sb1\"); changeString(sb1); System.out.println(sb1);//输出str1 change &#125;","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"源码分析","slug":"源码分析","permalink":"http://blog.loveyx815.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"字符串","slug":"字符串","permalink":"http://blog.loveyx815.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"设计模式-策略模式","slug":"设计模式-策略模式","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T11:09:01.642Z","comments":true,"path":"2020/04/19/设计模式-策略模式/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式-策略模式 概念 策略模式（Strategy），定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换，可以针对不同业务选择不同逻辑的执行。 场景应用 有一笔订单需要对它进行流程管理。从订单产生-&gt;订单入库-&gt;配送-&gt;确认订单完成，有这样一个流程。这里有订单入库、配送这两个动作标签，在每个订单产生动作标签的时候，执行的不同的业务处理。这里用简单的分支语句来实现就是： 1234567if(action==\"订单入库\")｛ //执行业务代码｝else if(action==\"配送\")&#123; //执行业务代码&#125;...... 如果这里的分支有很多层，那么这块代码复杂度就会很高，而且也不容易维护。 下面使用策略模式实现。 策略模式实现 1. 抽象出业务处理器，可以当做分支结构中选择器。这个只是抽象出来的模型，后面需要给他具体实现。 12345678910111213141516public abstract class InspectionSolver &#123; /** * 业务代码抽象 * @param orderId * @param userId */ public abstract void solve(Long orderId, Long userId); /** * 策略标识，决定执行哪一个策略 * @return */ public abstract String[] supports();&#125;2. 根据抽象模型定义出自己的业务处理器，这就是实际的业务代码，当系统确定你要执行的业务后，就会执行相应的业务代码进行处理。 12345678910111213141516171819202122232425262728//继承抽象业务处理器并实现自己的业务处理，//可以根据supports中拥有的动作绑定相应的业务代码//订单批量转仓@Componentpublic class ChangeWarehouseSolver extends InspectionSolver &#123; @Override public void solve(Long orderId, Long userId) &#123; System.out.println(\"订单\"+orderId+\"开始进行批量转仓了。。\"); &#125; @Override public String[] supports() &#123; return new String[] &#123;InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE&#125;; &#125;&#125;//订单转换快递@Componentpublic class ChangeShippingSolver extends InspectionSolver &#123; @Override public void solve(Long orderId, Long userId) &#123; System.out.println(\"订单\"+orderId+\"开始进行转快递了。。\"); &#125; @Override public String[] supports() &#123; return new String[] &#123;InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_SHIPPING&#125;; &#125;&#125; 3. 现在策略是有了，所以还需要个调用的过程。想要根据不同的策略执行不同的逻辑业务，需要运用AOP切面得到当前所有具体的策略实现类。然后将对应的supports字段和对应的策略实现类存放在一个Map中。通过Map中的Key-Value就能知道对应的动作的策略，从而实现一个动态处理逻辑的过程。 123456789101112131415161718192021222324@Componentpublic class InspectionSolverChooser implements ApplicationContextAware &#123; private Map&lt;String, InspectionSolver&gt; chooseMap = new HashMap&lt;&gt;(); private ApplicationContext context; @PostConstruct public void register()&#123; System.out.println(\"执行PostConstruct...\"); Map&lt;String, InspectionSolver&gt; solverMap = context.getBeansOfType(InspectionSolver.class); for (InspectionSolver solver : solverMap.values()) &#123; for (String support : solver.supports()) &#123; chooseMap.put(support,solver); &#125; &#125; &#125; public InspectionSolver choose(String type)&#123; return chooseMap.get(type); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.context=applicationContext; System.out.println(\"applicationc初始化。。。\"); &#125;&#125; 这里通过实现ApplicationContextAware这个上下文接口，可以获取所有在Spring中托管的bean。前面的 ChangeWarehouseSolver 和 ChangeShippingSolver 两个策略实现类使用@Component注解过，让他们在Spring容器中注册过bean，solverMap 这个Map是用在存放获取Spring容器中的InspectionSolver bean，chooseMap 这个Map用来存放策略对应的业务。再通过choose(type) 这个方法调用，得到不同动作类型的策略，实现业务处理。 ==@PostConstruct==这里在说下@PostConstruct这个注解。当一个类中construct构造方法、@Autowired、@PostConstruct的执行优先级是construct&gt;Autowired&gt;PostConstruct。所以当我们想要使用@Autowired注入的bean的时候，使用构造函数肯定获取不到bean，那么可以把相应的操作放到@PostConstruct这个注解下使用。 4. 策略模式使用编写测试类 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes= Application.class)// 指定spring-boot的启动类public class InspectionTest &#123; @Autowired private InspectionSolverChooser chooser; @Test public void test() throws Exception&#123; //准备执行动作 转入仓库 String taskType = InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE; Long orderId = 12345L; Long userId = 123L; //获取任务类型对应的solver InspectionSolver solver = chooser.choose(taskType); if (solver == null) &#123; throw new RuntimeException(\"任务类型暂时无法处理!\"); &#125; //调用不同solver的方法进行处理 solver.solve(orderId,userId); &#125;&#125; 系统枚举类 12345public enum InspectionConstant &#123; public static String INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE=\"转入仓库\"; public static String INSPECTION_TASK_TYPE_BATCH_CHANGE_SHIPPING=\"开始配送\";&#125; 测试结果 在这里插入图片描述 这里执行的是转入仓库的业务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.loveyx815.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"Docker从入坑到放弃","slug":"Docker/Docker从入坑到放弃","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:11:42.446Z","comments":true,"path":"2020/04/19/Docker/Docker从入坑到放弃/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/Docker/Docker%E4%BB%8E%E5%85%A5%E5%9D%91%E5%88%B0%E6%94%BE%E5%BC%83/","excerpt":"","text":"Docker从入坑到放弃 环境安装问题 windows7安装docker异常 ：looks like something went wrong in step ‘looking for vboxmanage.exe’ 解决方案：从安装目录的 start.sh脚本开始排查，很大可能是因为电脑的环境变量没有创建成功，所以需要把脚本对应的变量打印出来看看。 打印语句：echo “$VBOX_MSI_INSTALL_PATH”#“变量名称”read param 在这里插入图片描述 **异常信息显示是‘looking for vboxmanage.exe’ ，所以 主要在这里排查，完善对应的变量名（这里已经是替换过的全命名路径了）** 保存脚本后，在运行启动快捷方式 在这里插入图片描述 运行成功","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/tags/Docker/"}]},{"title":"RocketMQ消息队列-初识","slug":"mq/RocketMQ消息队列","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T07:49:10.833Z","comments":true,"path":"2020/04/19/mq/RocketMQ消息队列/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/mq/RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"RocketMQ消息队列[TOC] 简介：RocketMQ具有灵活的扩展性、海量消息堆积能力、支持顺序消息、支持多种消息过滤方式、支持事务消息、支持回溯消费。 四大核心组件：NameServer、Broker、Producer、Consumer，每个组件都可以部署成集群模式进行水平扩展。 Producer 生产者负责生产消息，Rocketmq提供了同步、异步、单向三种方式发送消息。 Consumer 消费者负责消费消息，从消息服务器拉取消息并将其输入用户应用程序。 Broker 消息服务器是消息存储中心，主要用于接收生产者的消息进行存储，消费者从这里获取消息。并且还存储与消息有关的元数据（包括用户组、消费进度偏移量、队列信息等） NameServer 名称服务器用来保存Broker相关元信息并给生产者和消费者查找Broker信息。 1.环境搭建（1） 从官网下载RocketMQ服务包 ,将其解压至服务器目录 1580280760569 ，启动nameserver和broker服务（需要安装好JDK环境，没装的话先移步安装JDK）。 （2） 12#后台启动nameservernohup sh bin/mqnamesrv &amp; 观察启动目录下的nohup.out日志文件，是否启动成功！ 这里我使用的是默认的配置环境进行启动，结果报错了，日志显示如下 12345678Java HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future releaseJava HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000006c0000000, 2147483648, 0) failed; error='Cannot allocate memory' (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (mmap) failed to map 2147483648 bytes for committing reserved memory.# An error report file with more information is saved as:# /home/rocketmq-all-4.6.0-bin-release/bin/hs_err_pid7597.log 说是内存分配不足。 解决方案：查看mqnamesrv脚本，最后运行了runserver.sh，所以我们修改runserver.sh这个脚本的运行空间，找到JAVA_OPT这一行，修改成 1JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms128m -Xmx128m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\" 内存大小可根据实际情况设定。 （3） 12#后台启动brokernohup sh bin/mqborker -n ip:9876 &amp; 观察启动目录下的nohup.out日志文件，是否启动成功！ 我这里日志显示内存不够失败，参考（2）中的解决方案，修改runbroker.sh的运行内存参数，再查看日志文件，启动成功！ 2.实现生产者和消费者 这里采用推送型消费模式进行消息消费，需要在消费者启动的过程中注册一个消息监听器，监听订阅消息的获取。 消费者： 12345678910111213141516171819202122232425262728293031323334353637383940public class Consumer &#123; public static void main(String[] args) throws Exception&#123; //创建一个消费者，帮你设置一个消费者组 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"shi_consumer_group\"); //指定nameserver 地址 consumer.setNamesrvAddr(\"ip:9876\"); //设置consumer第一次启动时从队列首或尾开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //订阅指定Topic下的所有消息 consumer.subscribe(\"topic_example_java\",\"*\"); //注册消息监听器 consumer.registerMessageListener( new MessageListenerConcurrently()&#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123; //默认list里只有一条消息，可以通过设置参数来批量接受消息 if (list != null)&#123; for (MessageExt ext:list)&#123; try &#123; System.out.println(new Date()+new String(ext.getBody(),\"UTF-8\")); &#125;catch (UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; &#125; &#125; else &#123; System.out.println(\"么有监听到消息。。。\"); &#125; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125; ); //消费者对象在使用之前必须要调用start方法初始化 consumer.start(); System.out.println(\" Consumer started...\"); &#125;&#125; 消息生产者： 1234567891011121314151617181920212223242526272829public class Producer &#123; public static void main(String[] args) throws MQClientException, UnsupportedEncodingException, RemotingException, InterruptedException, MQBrokerException &#123; //创建一个消息生产者，并设置一个消息生产组 DefaultMQProducer producer =new DefaultMQProducer(\"shi_producer_group\"); //指定nameSERVER地址 producer.setNamesrvAddr(\"ip:9876\"); //初始化producer，在整个生命周期中只需要初始化一次 producer.start(); for (int i =0 ;i&lt;100;i++)&#123; //创建一个消息对象，指定其主题、标签、消息内容 Message message = new Message( \"topic_example_java\", //消息主题 \"TagA\",//消息标签 (\"Hello Java demo rocketMQ\"+i).getBytes(RemotingHelper.DEFAULT_CHARSET)//消息内容 ); //发送消息并返回结果 SendResult sendResult = producer.send(message); System.out.printf(\"%s%n\",sendResult); &#125; //一旦生产者实例不再被使用，则将其关闭，包括清理资源、关闭网络连接等 producer.shutdown(); &#125;&#125; 分别启动消费者和生产者，生产者发布携带topic的消息，消费者去订阅该topic，通过监听，即可获取消息。 1580363958517 生产者生产的100条消息已经被消费了 通过rocketmq-console可视化界面可以看到消费信息已产生 1580364346073 这里提下rocketmq-console是rocketmq官方开源的控制台项目，可以监测mq运行情况。可以通过rocketmq官方的github的release-rocketmq-console-1.0.0分支获取该源码。 这里有个地方需要注意，很多资料上写的都是本机配置rocketmq，所以他们启动的都是localhost:9876这个broker，包括在代码中生产者、消费者制定nameserver地址也是localhost:9876。 使用云服务器部署mq的或者想使用虚拟机ip的需要注意了： 如若启动了mqnamesrv和mqbroker这两个服务，先杀掉。然后修改rocketmq解压目录下conf/broker.conf，新增个brokerIP1=你的服务器公网ip 。 启动mqnamesrv和mqbroker 1234#启动mqnamesrvnohup sh bin/mqnamesrv &amp;#启动mqbroker，-c可以自定义配置文件启动，这里使用上面修改conf/borker.confnohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf 服务器防火墙放行9876和10911端口，云服务器设置安全组规则，同样放行9876和10911（画重点，血的教训） 1580365573265 之前不知道为什么就设置了10909端口，后来消息可以生产但无法消费。一直以为自己的端口都放开了，弄了半天发现还是端口没放开。。。 3.基于Aop托管的实现 把生产者和消费者的实例放入spring bean中，利用Aop进行管理，方便调用 新建生产者、消费者和监听器bean. 生产者bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @Auther: Yonggang Shi * @Date: 2020/01/30 15:52 * @Description: spring IoC实现生产者 */public class SpringProducer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private String producerGroupName; private String nameServerAddr; private DefaultMQProducer producer; public SpringProducer(String producerGroupName, String nameServerAddr) &#123; this.producerGroupName = producerGroupName; this.nameServerAddr = nameServerAddr; &#125; public void init() throws Exception &#123; logger.info(\"开始启动消息生产者服务。。。\"); //创建一个消息生产者，并设置一个消息生产者组 producer = new DefaultMQProducer(producerGroupName); //指定nameserver地址 producer.setNamesrvAddr(nameServerAddr); producer.start(); logger.info(\"消息生产者服务启动成功。\"); &#125;/* * @Description: 销毁对象 * @Param: [] * @Return: void * @Author: Yonggang Shi * @Date: 2020/1/30/030 下午 4:28 */ public void destroy() &#123; logger.info(\"开始关闭消息生产者服务。。\"); producer.shutdown(); logger.info(\"消息生产者服务已关闭\"); &#125; public DefaultMQProducer getProducer()&#123; return producer; &#125;&#125; 消费者bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @Auther: Yonggang Shi * @Date: 2020/01/30 16:29 * @Description: */public class SpringCousumer &#123; private Logger logger =LoggerFactory.getLogger(this.getClass()); private String consumerGroupName; private String nameServerAddr; private String topicName; private DefaultMQPushConsumer consumer; private MessageListenerConcurrently messageListenerConcurrently; public SpringCousumer(String consumerGroupName,String nameServerAddr,String topicName,MessageListenerConcurrently messageListener)&#123; this.consumerGroupName=consumerGroupName; this.nameServerAddr=nameServerAddr; this.topicName=topicName; this.messageListenerConcurrently=messageListener; &#125; public void init() throws Exception&#123; logger.info(\"开始启动消费者服务。。\"); consumer=new DefaultMQPushConsumer(consumerGroupName); consumer.setNamesrvAddr(nameServerAddr); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(topicName,\"*\"); consumer.registerMessageListener(messageListenerConcurrently); consumer.start(); logger.info(\"消费者服务已启动。。。\"); &#125; public void destory()&#123; logger.info(\"开始关闭消息者服务。。。\"); consumer.shutdown(); logger.info(\"消费者服务已关闭！\"); &#125; public DefaultMQPushConsumer getConsumer()&#123; return consumer; &#125;&#125; 消息监听器bean 123456789101112131415161718192021222324/** * @Auther: Yonggang Shi * @Date: 2020/01/30 17:11 * @Description: 消息监听逻辑 */public class MessageListener implements MessageListenerConcurrently &#123; private Logger logger =LoggerFactory.getLogger(this.getClass()); @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123; if (list!=null)&#123; for (MessageExt ext : list)&#123; try &#123; logger.info(\"监听到消息：\"+new String(ext.getBody(),\"UTF-8\")); &#125;catch (UnsupportedEncodingException e)&#123; logger.info(\"解码异常\"+e); &#125; &#125; &#125; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125; 由于本项目是基于springboot开发，这里直接新建个config配置类，注入上面建的bean 注意：下面的nameserver的ip需改成自己实际环境的ip 12345678910111213141516171819202122232425262728293031323334353637/** * @Auther: Yonggang Shi * @Date: 2020/01/30 17:26 * @Description: 消息生产者实例配置 */@Configurationpublic class ConfigBean &#123; @Autowired private ApplicationContext applicationContext; /* * @Description: 生产者实例化 * @Param: [] * @Return: cn.loveyx815.rocketmq.spring.SpringProducer * @Author: Yonggang Shi * @Date: 2020/1/30/030 下午 5:35 */ @Bean(initMethod = \"init\",destroyMethod = \"destroy\") public SpringProducer getProducer()&#123; return new SpringProducer(\"spring_producer_group\",\"ip:9876\"); &#125; @Bean(name = \"messageListener\") public MessageListener messageListener()&#123; return new MessageListener(); &#125; @Bean(initMethod = \"init\",destroyMethod = \"destory\") public SpringCousumer getCousumer()&#123; //ApplicationContext context = return new SpringCousumer(\"spring_producer_group\",\"ip:9876\",\"spring-rocketMQ-topic\",messageListener()); &#125;&#125; 到此为止，准备工作都已完成，现在写两个单元测试进行验证下代码是否有问题 1234567891011121314151617181920/** * @Auther: Yonggang Shi * @Date: 2020/01/31 14:45 * @Description: 消费者单测 */@SpringBootTestpublic class SpringConsumerTest &#123; @Autowired private SpringCousumer cousumer; @Test public void consume() throws Exception &#123; Thread.sleep(1000*200); cousumer.getConsumer().shutdown(); &#125;&#125; 123456789101112131415161718192021222324252627282930/** * @Auther: Yonggang Shi * @Date: 2020/01/31 14:44 * @Description: 生产者单测 */@SpringBootTestpublic class SpringProducerTest &#123; @Autowired private SpringProducer producer; @Test public void sendMessage() throws Exception&#123; for (int i =0;i&lt;20;i++)&#123; Message message = new Message( \"spring-rocketMQ-topic\", null, (\"spring-RocketMQ-demo\"+i).getBytes(RemotingHelper.DEFAULT_CHARSET) ); SendResult sendResult = producer.getProducer().send(message); System.out.printf(\"%s%n\",sendResult); &#125; &#125;&#125; 最后启动两个test，得到输出信息 4.消息顺序处理 在业务中可能需要按照顺序消费的场景，而RocketMQ本身就支持这种顺序消费。 如电商系统中订单产生-加入购物车-将下单消息写入消息队列-用户取消-将取消订购的消息加入消息队列-从队列中消费订购消息-从队列中消费取消订购消息-往数据库中写入订购消息-从数据库中删除订购消息，在最后写入数据库和从数据库删除操作时，必须按照消息顺序执行，否则就会发生取消操作失败。 实际上与之前的生产消费类似，下面仅介绍下需要注意的地方。 消息生产者bean注入的时候，需要实例化一个消息队列选择器（MessageQueueSelector），新建个选择器类实现MessageQueueSelector这个接口，自定义消息存储的规则，那些消息会进入同一个队列。实际调用生产者发送消息的时候send()，传入新建消息选择器的对象和对应消息和参数 123public SendResult send(Message msg, MessageQueueSelector selector, Object arg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123; return this.defaultMQProducerImpl.send(msg, selector, arg); &#125; 通过实现这个重载方法来进入消息队列 消费者bean注入不同的是，消息监听器的实现接口不同，原来是用MessageListenerConcurrently，这种消息消费是无序的，所以我们想要有序的需实现MessageListenerOrderly","categories":[{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/categories/MQ/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/tags/MQ/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.loveyx815.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"RocketMQ消息队列-分布式事务","slug":"mq/RocketMQ消息队列之分布式事务","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T07:49:42.624Z","comments":true,"path":"2020/04/19/mq/RocketMQ消息队列之分布式事务/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/mq/RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"RocketMQ消息队列[TOC] 基于RocketMQ的分布式事务 在介绍RocketMQ的分布式事务之前，先来了解下什么事分布式事务？ 一、分布式事务 简介 在分布式系统中，不止使用一个数据库，比如订单系统使用db_order数据库，产品系统使用的是db_product数据库，在订单系统中只能保证订单相关操作的事务，在产品系统中只能保证产品相关操作的事务。比如：如果在订单系统中进行生成订单、扣减库存的业务，如果出现异常，那么创建订单的事务会回滚，而扣减库存的事务则不会，因为本地事务是不能夸数据库的。跨库的事务就属于分布式事务。 把分布式系统中两个相关操作看成是一个单元，比如创建订单和修改库存的操作，该单元要么一起成功，要么一起失败，这就是分布式事务。 关于分布式事务你不得不知的两个理论： 1、CAP定理CAP原则又称CAP定理，指的是在一个分布式系统中，WEB服务无法同时满足以下3个特性： 一致性(Consistency) ： 在分布式系统中数据一旦更新，所有数据变动都是同步的 可用性(Availability) ： 好的响应性能，每个操作都必须有预期的响应结束 分区容错性(Partition tolerance) ： 在网络分区的情况下，即使出现单个节点无法可用，系统依然正常对外提供服务 首先在分布式系统中，横向扩展策略依赖于数据分区，所以一般会在一致性和可用性上做出牺牲。 2、BASE理论BASE理论中的三个特性： Basically Available（基本可用） Soft state（软状态） Eventually consistent（最终一致性） 三个特性分别指的是： （1）基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。 （2）软状态，和硬状态对应，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。 （3）最终一致性强调的是系统所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要试试保证系统数据的强一致性。 BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consist ency）。————————————————版权声明：本文为CSDN博主「坏菠萝」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/abcwanglinyong/article/details/82116669 二、分布式事务解决方案 分布式事务解决方案有很多种，这里针对RocketMQ本身介绍下两阶段提交（2PC）。因为本身RocketMQ的分布式事务消息就是基于消息中间件模拟的两阶段提价（2PC）。 主要分为以下几个步骤 系统A先向消息中间件发送一条预备消息，消息中间件保存还该消息后向系统A发送确认消息 系统A接收到MQ的确认消息后，执行本地事务 系统A根据本地事务执行结果再向MQ发送提交信息，以提交二次确认 MQ收到二次确认消息后，不预备消息标记为可投递，订阅者最终讲接收到该消息 在这过程中是如何进行回滚操作？ 在本地事务未执行之前，也就是上面的1和2出错的话，不会进入后面的阶段，也就不会有问题 第3步出错系统A会实现一个消息回查接口，MQ服务端在等不到系统A反馈时会轮询该消息回查接口，检查系统A的本地事务执行结果。如果事务成功执行则进入下个阶段，否则回滚到第一步中。 第4布出错，此时系统A的本地事务已经提交成功，MQ服务端通过回查接口能够检查到该事务执行成功，那么由MQ服务端将预备消息标记为可投递，从而完成消息事务的处理。 至此可实现跨系统是分布式事务了。 整体的分布式事务被拆分成一个消息事务（系统A的本地事务+发消息）+系统B的本地事务，系统B的操作由消息驱动，这样系统A和系统B的事务便绑定在一起。 RocketMQ整体交互流程图如下： 事务发起方首先发送准本预备消息到MQServer MQServer向事务发起方ACK确认消息发送成功 事务发起方接收到确认消息后执行事务 事务发起方根据本地事务的执行结果返回commit或rollback给MQserver。如果发送的是rollback，则MQ将删除该预备消息不进行下发；否则MQ会把该预备消息发送给Consumer 如果在执行本地事务过程中该应用挂了或者超时，第4步提交的二次确认消息最终没有到达MQServer，MQServer将在经过一定时间后对该消息发起消息回查，通过不停的询问同组的其他的Producer来获取状态 发送方接受到回查消息后查询对应消息的本地事务执行结果 根据回查的本地事务的最终执行结果再次提交二次确认 消费端的消息成功机制是由MQ保证的 三、RocketMQ事务消息实例建议大家使用MQ的时候要选择MQ版本4.3以上的，而且pom文件引入的rocketmq-client版本号要与你服务器上的版本号一致，否则可能会出现No route info of this topic这样的异常信息，被这个坑惨了 事务消息生产者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @Auther: Yonggang Shi * @Date: 2020/02/03 17:11 * @Description: */public class TransactionProducer &#123; private static Logger logger = LoggerFactory.getLogger(TransactionProducer.class); public static void main(String[] args) throws Exception &#123; TransactionMQProducer producer = new TransactionMQProducer(\"transaction_producer_group\"); producer.setNamesrvAddr(Consts.MQ_ADDR); ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(2000), (Runnable r) -&gt; &#123; Thread thread = new Thread(r); thread.setName(\"client-transaction-msg-check-thread\"); return thread; &#125;); //设置本地事务执行的线程池 producer.setExecutorService(executorService); producer.setTransactionListener(new TransactionListener() &#123; @Override public LocalTransactionState executeLocalTransaction(Message message, Object o) &#123; //本地事务处理逻辑 logger.info(\"本地事务执行。。。\"); logger.info(\"消息标签：\"+new String(message.getTags())); logger.info(\"消息内容：\"+new String(message.getBody())); String tag = message.getTags(); if (tag.equals(\"Transaction1\"))&#123; //消息的标签如果是Transaction1,则返回事务失败标记 logger.error(\"模拟本地事务执行失败\"); return LocalTransactionState.ROLLBACK_MESSAGE; &#125; logger.info(\"模拟本地事务成功\"); return LocalTransactionState.COMMIT_MESSAGE; &#125; @Override public LocalTransactionState checkLocalTransaction(MessageExt messageExt) &#123; //消息回查接口 logger.info(\"服务器调用消息回查接口\"); logger.info(\"消息标签：\"+new String(messageExt.getTags())); logger.info(\"消息内容：\"+new String(messageExt.getBody())); return LocalTransactionState.COMMIT_MESSAGE; &#125; &#125;); producer.start(); for (int i =0 ;i&lt;2;i++)&#123; Message message=new Message(\"TopicTransaction\",\"Transaction\"+i,(\"Hello Rocakmq transaction\").getBytes()); SendResult sendResult =producer.sendMessageInTransaction(message,null); logger.info(String.valueOf(sendResult)); logger.info(\"\"); TimeUnit.MICROSECONDS.sleep(10); &#125; for (int i =0 ;i&lt;100;i++)&#123; Thread.sleep(1000); &#125; producer.shutdown(); &#125;&#125; 与普通生产者不同的地方是，这里需要调用setTransactionListener方法，通过自己实现TransactionListener接口的executeLocalTransaction执行本地事务和checkLocalTransaction消息回查方法 执行结果说明有个事务消息挂了，实际上发送过去的就只有一条 事务消息消费者 1234567891011121314151617181920212223242526272829303132333435363738/** * @Auther: Yonggang Shi * @Date: 2020/02/03 22:11 * @Description: */public class TransactionConsumer &#123; private static Logger logger = LoggerFactory.getLogger(TransactionConsumer.class); public static void main(String[] args) throws MQClientException &#123; DefaultMQPushConsumer consumer =new DefaultMQPushConsumer(\"transaction_consumer_group\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.setNamesrvAddr(Consts.MQ_ADDR); consumer.subscribe(\"TopicTransaction\",\"*\"); consumer.registerMessageListener(new MessageListenerConcurrently() &#123; private Random random = new Random(); @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123; for (MessageExt msg: list) &#123; logger.info(\"消息消费者接收到消息\"+msg); logger.info(\"接收到的消息标签：\"+new String(msg.getTags())); logger.info(\"接收到消息内容：\"+new String(msg.getBody())); &#125; try &#123; //模拟业务处理 TimeUnit.SECONDS.sleep(random.nextInt(5)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return ConsumeConcurrentlyStatus.RECONSUME_LATER; &#125; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125;); consumer.start(); &#125;&#125; 执行事务消息消费者，仅消费了Transaction0，说明本地事务消息失败的没有被发过来 四、分布式事务实现新用户注册送积分 背景介绍：新用户注册赠送积分。这里的流程就是把用户表格积分表分别放在不同的库，实现两者的跨库事务操作。 这里我们主要介绍下核心代码，完整的源码可以follow我的大型仓库 https://github.com/rainandsunshine/Poet.git 下面分为两块，一个是配置双数据源，单个数据源不能实现跨库操作；二是RocketMQ的分布式事务在具体业务中如何实现。 配置双数据源，也就是一个系统里面连接两个库。这个项目使用的是JdbcTemplate作为持久层的开发，在SpringBoot中直接新建个配置类，给数据源都绑定好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Auther: Yonggang Shi * @Date: 2020/02/04 22:58 * @Description: 双数据源配置 */@Configurationpublic class DataSourceConfig &#123; @Bean(name = \"testDataSource\") @Primary @Qualifier(\"testDataSource\") @ConfigurationProperties(prefix=\"spring.datasource.hikari.mysql\") public DataSource testDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = \"formalDataSource\") @Qualifier(\"formalDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.formal.mysql\") public DataSource formalDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name=\"testJdbcTemplate\") public JdbcTemplate testJdbcTemplate ( @Qualifier(\"testDataSource\") DataSource testDataSource ) &#123; return new JdbcTemplate(testDataSource); &#125; @Bean(name = \"formalJdbcTemplate\") public JdbcTemplate formalJdbcTemplate( @Qualifier(\"formalDataSource\") DataSource formalDataSource)&#123; return new JdbcTemplate(formalDataSource); &#125; /* * @Description:用户DAO层bean， 通过参数注入对应的jdbctemplate，实现对库绑定 * @Param: [jdbcTemplate] * @Return: cn.loveyx815.rocketmq.mqtransaction.dao.UserDao * @Author: Yonggang Shi * @Date: 2020/2/5/005 下午 11:57 */ @Bean(name=\"userDao\") public UserDao getUserDao(@Qualifier(\"testJdbcTemplate\") JdbcTemplate jdbcTemplate)&#123; UserDao userDao =new UserDao(); userDao.setJdbcTemplate(jdbcTemplate); return userDao; &#125; /* * @Description:积分DAO层bean， 通过参数注入对应的jdbctemplate，实现对库绑定 * @Param: [jdbcTemplate] * @Return: cn.loveyx815.rocketmq.mqtransaction.dao.UserDao * @Author: Yonggang Shi * @Date: 2020/2/5/005 下午 11:57 */ @Bean(name=\"pointDao\") public PointDao getPointDao(@Qualifier(\"formalJdbcTemplate\") JdbcTemplate jdbcTemplate)&#123; PointDao pointDao =new PointDao(); pointDao.setJdbcTemplate(jdbcTemplate); return pointDao; &#125;&#125; 配置多数据源一定有个主要的数据源，不然程序加载就不能识别默认的，导致报错。@Primary注解加在你想加的DataSource上。 先注入两个DataSource的bean后，再分别注入JdbcTemplate中，最后把持久层的userDAO和pointDAO分贝注入不同的Jdbctemplate的bean，这样就可以实现多数经验绑定了。 下面就是介绍事务消息生产者和消费者 除了那些基本的配置之外，主要的是在事务消息可以实现分布式事务，基于2PC(二阶段提交)前文已经介绍过了。 特别的地方就是在消息生产者生产的时候需要添加个本地事务监听器，用来监听本地事务执行状态，然后再发送消息。 而消费者也需要自己实现MessageListenerConcurrently接口的方法，可以在消费消息的时候做一些业务处理 消息监听器TransactionMessageListener 123456789101112131415161718192021222324252627282930313233343536/** * @Auther: Yonggang Shi * @Date: 2020/02/04 18:50 * @Description: 事务消息监听器，用作消费者消费的监听逻辑实现 */@Componentpublic class TransactionMessageListener implements MessageListenerConcurrently &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Resource private PointService pointService; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123; try &#123; for (MessageExt message:list)&#123; logger.info(\"消息消费者接收到消息:\"+message); logger.info(\"接收到消息内容:\"+new String (message.getBody())); //从消息体中获取积分消息对象 UserPointMessage userPointMessage= JSON.parseObject(message.getBody(),UserPointMessage.class); if (userPointMessage!=null)&#123; Point point = new Point(); point.setUserId(userPointMessage.getUserId()); point.setAmount(userPointMessage.getAmount()); //保存用户积分记录并提交本地事务 pointService.savePoint(point); &#125; &#125; &#125;catch (Exception e)&#123; logger.error(\"消息消费出错\"+e); return ConsumeConcurrentlyStatus.RECONSUME_LATER; &#125; //正常消费成功 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125; 本地事务监听器UserLocalTransactionListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Auther: Yonggang Shi * @Date: 2020/02/04 18:25 * @Description: 本地事务监听器，用作生产者生产消息的逻辑 */@Componentpublic class UserLocalTransactionListener implements TransactionListener &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserService userService; @Override public LocalTransactionState executeLocalTransaction(Message message, Object o) &#123; //本地事务处理逻辑 logger.info(\"本地事务执行。。。\"); logger.info(\"消息标签：\"+new String(message.getTags())); logger.info(\"消息内容：\"+new String(message.getBody())); //从消息体重获取积分消息对象 UserPointMessage userPointMessage = JSON.parseObject(message.getBody(), UserPointMessage.class); //保存用户记录并提交本地事务 userService.saveUser(userPointMessage.getUserId(),userPointMessage.getUserName()); return LocalTransactionState.COMMIT_MESSAGE; &#125; @Override public LocalTransactionState checkLocalTransaction(MessageExt messageExt) &#123; //消息回查接口 logger.info(\"服务器调用消息回查接口\"); logger.info(\"消息标签：\"+new String(messageExt.getTags())); logger.info(\"消息内容：\"+new String(messageExt.getBody())); //从消息体重获取积分消息对象 UserPointMessage userPointMessage = JSON.parseObject(messageExt.getBody(),UserPointMessage.class); if (userPointMessage!= null)&#123; String userId = userPointMessage.getUserId(); if (userService.getById(userId) != null)&#123; logger.info(\"本地插入用户表成功！\");// 表示本地事务执行成功 return LocalTransactionState.COMMIT_MESSAGE; &#125; &#125; return LocalTransactionState.ROLLBACK_MESSAGE; &#125;&#125; 通过使用@Component注解来标识这两个监听器注入Spring容器，然后在生产者、消费者配置类中分别引用这两个监听器bean。 生产者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Auther: Yonggang Shi * @Date: 2020/02/04 17:55 * @Description: 消息生产者 */public class TransactionSpringProducer &#123; private Logger logger = LoggerFactory.getLogger(getClass()); private String producerGroupName; private String nameServerAdd; private int corePoolSize = 1; private int maximumPoolSize = 5; private long keepAliveTime = 100; private TransactionMQProducer producer; private TransactionListener transactionListener; public TransactionSpringProducer(String producerGroupName,String nameServerAdd,int corePoolSize,int maximumPoolSize,long keepAliveTime,TransactionListener transactionListener)&#123; this.corePoolSize=corePoolSize; this.keepAliveTime=keepAliveTime; this.maximumPoolSize=maximumPoolSize; this.nameServerAdd=nameServerAdd; this.producerGroupName=producerGroupName; this.transactionListener=transactionListener; &#125; public void init() throws Exception&#123; logger.info(\"开始启动消息生产者服务。。。\"); producer = new TransactionMQProducer(producerGroupName); producer.setNamesrvAddr(nameServerAdd); ExecutorService executorService = new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(2000),(Runnable r )-&gt;&#123; Thread thread = new Thread(r); thread.setName(\"client-transaction-msg-check-thread\"); return thread; &#125;); producer.setExecutorService(executorService); producer.setTransactionListener(transactionListener); producer.start(); logger.info(\"消息生产者已启动！！！\"); &#125; public void destory()&#123; logger.info(\"开始关闭消息生产服务。。\"); producer.shutdown(); logger.info(\"生产者服务已关闭\"); &#125; public DefaultMQProducer getProducer()&#123; return producer; &#125;&#125; 消费者 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Auther: Yonggang Shi * @Date: 2020/02/04 18:41 * @Description: 消费者 */public class TransactionSpringConsumer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private String consumerGropuName; private String nameServerAddr; private String topicName; private DefaultMQPushConsumer consumer; private MessageListenerConcurrently messageListener; public TransactionSpringConsumer(String consumerGropuName,String nameServerAddr,String topicName,MessageListenerConcurrently messageListener)&#123; this.consumerGropuName=consumerGropuName; this.messageListener=messageListener; this.nameServerAddr=nameServerAddr; this.topicName=topicName; &#125; public void init () throws Exception&#123; logger.info(\"开始启动消息消费者服务。。。\"); consumer=new DefaultMQPushConsumer(consumerGropuName); consumer.setNamesrvAddr(nameServerAddr); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(topicName,\"*\"); consumer.registerMessageListener(messageListener); consumer.start(); logger.info(\"消息消费者服务启动成功\"); &#125; public void destory()&#123; logger.info(\"开始关闭消息消费者服务。。\"); consumer.shutdown(); logger.info(\"消费者服务已关闭\"); &#125; public DefaultMQPushConsumer getConsumer()&#123; return consumer; &#125;&#125; 生产者、消费者配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Auther: Yonggang Shi * @Date: 2020/02/04 18:41 * @Description: 消费者 */public class TransactionSpringConsumer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private String consumerGropuName; private String nameServerAddr; private String topicName; private DefaultMQPushConsumer consumer; private MessageListenerConcurrently messageListener; public TransactionSpringConsumer(String consumerGropuName,String nameServerAddr,String topicName,MessageListenerConcurrently messageListener)&#123; this.consumerGropuName=consumerGropuName; this.messageListener=messageListener; this.nameServerAddr=nameServerAddr; this.topicName=topicName; &#125; public void init () throws Exception&#123; logger.info(\"开始启动消息消费者服务。。。\"); consumer=new DefaultMQPushConsumer(consumerGropuName); consumer.setNamesrvAddr(nameServerAddr); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe(topicName,\"*\"); consumer.registerMessageListener(messageListener); consumer.start(); logger.info(\"消息消费者服务启动成功\"); &#125; public void destory()&#123; logger.info(\"开始关闭消息消费者服务。。\"); consumer.shutdown(); logger.info(\"消费者服务已关闭\"); &#125; public DefaultMQPushConsumer getConsumer()&#123; return consumer; &#125;&#125; 这样就已经完成了分布式事务生产消费的工作，还有相关的service和dao代码就不贴了，这里 都有！ 单元测试分布式事务生产消费 1234567891011121314151617181920/** * @Auther: Yonggang Shi * @Date: 2020/02/04 23:24 * @Description: */@RunWith(SpringRunner.class)@SpringBootTest(classes = &#123;RocketmqApplication.class&#125;)public class MQConfigTest &#123; @Autowired private UserService userService; @Test public void newUser() throws Exception&#123; userService.newUserAndPoint(\"分布式事务测试\",100); Thread.sleep(5000); &#125;&#125; 结果如下 1580921850968 我们再 看下两个库是否也更新了 1580922010823 至此分布式事务已完成实现","categories":[{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/categories/MQ/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/tags/MQ/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.loveyx815.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"JVM复习","slug":"JVM/JVM复习","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T07:46:41.738Z","comments":true,"path":"2020/04/19/JVM/JVM复习/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/JVM/JVM%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"JVM复习 基于JDK1.7的研究 一、Java内存区域与内存溢出 上图为jdk1.7的内存模型，下图借用下别人的1.8的图 在这里插入图片描述 程序计数器 指示当前线程所执行的字节码的行号，编译字节码执行的命令，进而程序才能一步步的执行下去。 Java虚拟机栈 线程私有，生命周期与线程相同。 每个方法在执行时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等。方法从调用到执行完成的过程中，就饿对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表：存放了编译期间各基本数据类型、对象引用和returnAddress类型。其所需要的内存空间在编译期间完成分配，所以在方法运行期间是不会改变局部变量表的大小。 本地方法栈 与虚拟机栈类似，不同的是本地方法栈是为jvm调用Native方法服务。 Java堆 线程共享，存放对象实例。堆可以存在在物理上不连续，只要逻辑上连续就行。（GC在后面讲） 方法区 线程共享，用于存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 运行时常量池 方法区的一部分，存放Class文件在编译期间生产的各种字面常量和符号引用。Java中并非预置在Class文件中的常量池才会被放入常量池区。在运行期间也可以将新的常量放入该区域，如String类的intern()方法 直接内存 我理解的是为了方便JVM在Java堆和Native堆中来回复制数据设置的缓冲区。直接内存并不是JVM运行时数据区的一部分，这是一种基于通道和缓冲区的I/O方式。可以通过一个存储子啊Java堆中DirectByteBuffer对象作为这块内存的引用进行操作。 二、对象的创建JVM接受到一个new的指令是，首先会去常量池中寻找该类的符号引用，然后检察这个符号引用代表的类是否已经加载、解析和初始化过。如果没有则先执行类加载过程。 空间划分 通过类接在的检查后，JVM为该对象分配内存（内存大小在类加载完后就确定了）。若Java堆的空间是规整连续的采用的分配算法是“指针碰撞”，直接移动与对象大小相同的距离指针分配内存。否则采用“空闲列表”分配，对于堆空间非连续的，用一张空闲记录表记录当前空闲的内存块，在为对象分配内存的时候，从空闲表中找到合适的空间进行分配，同时更新空闲表。 内存分配完后，JVM将分配到内存的空间全都初始化为零，最后再执行方法进行我们想要的初始化对象 对象的内存布局 在HotSpot虚拟机中，对象在内存中分为：对象头+实例数据+对齐填充。 对象头：包含了两部分信息，一部分用于存储对象自身的运行时数据（哈希吗、GC年龄代、锁状态、线程持有的锁等）；另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。若对象是个数组，对象头中还需有一块用于记录数组长度的数据。 实例数据：是对象真正存储的有效信息 对齐填充：对象的大小必须是8的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 三、内存分配与回收 大多数情况下，对象在新生代Eden区中分配，当Eden去没有足够的空间进行分配的时候虚拟机会进行MinorGC MinorGC：新生代GC，速度较快 FullGC/MajorGC：老年代GC，速度很慢 大对象直接进入老年代 -XX:PretenureSizeThreshold 令大于这个设置的值得对象直接进入老年代 ，Serial、ParNew有效。避免在新生代不停地复制 存活久的对象将进入老年代 对象计数器：对象在Eden区出生并经过第一次MinorGC后任然存活，移动进入Survivor空间，且对象年龄设置为1。对象在survivor区中每熬过一次MinorGC，年龄+1。当年龄增加到阈值（默认15），就进入老年代。 动态对象年龄判定 当Survivor空间中相同年龄所有对象大小&gt;Survivor/2大小，年龄&gt;=该年龄的对象就可以直接进入老年代，无需等到年龄阈值 空间分配担保 JDK 6 Update24之前： 在MinorGC之前，JVM会检查老年代的最大连续可用空间是否大于新生代所有对象空间。 大于：MinorGC是安全执行的 否则：JVM会去查看HandlePromotionFailure设置值是否允许担保失败。 ​ 允许：检查老年代最大可用的连续空间是否大于历次晋升老年代对象的平均大小 ​ 大于：尝试一次MinorGC ​ 否则：进行FullGC ​ 否则：进行FullGC JDK 6 Update24之后： 只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小就会MinorGC，否则将进行FullGC","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"JVM","slug":"Java开发总结/JVM","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://blog.loveyx815.cn/tags/JVM/"}]},{"title":"Configuration注解中引用bean","slug":"summary/@Configuration注解中引用bean","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:21:16.163Z","comments":true,"path":"2020/04/19/summary/@Configuration注解中引用bean/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/@Configuration%E6%B3%A8%E8%A7%A3%E4%B8%AD%E5%BC%95%E7%94%A8bean/","excerpt":"","text":"@Configuration注解中引用bean 背景介绍：需要在一个配置类里面引用一个bean 直接上代码 12345678910111213141516@Configuration@ComponentScan(value = \"cn.loveyx815.rocketmq.mqtransaction.message\")public class MQConfig &#123; @Bean(name = \"prooducer\", initMethod = \"init\", destroyMethod = \"destory\") @DependsOn(value = \"userLocalTransactionListener\") public TransactionSpringProducer transactionSpringProducer(UserLocalTransactionListener userLocalTransactionListener) &#123; return new TransactionSpringProducer(\"transaction_spring_producer_group\", Consts.MQ_ADDR, 2, 5, 1000, userLocalTransactionListener); &#125; @Bean(name = \"consumer\", initMethod = \"init\", destroyMethod = \"destory\") @DependsOn(value = \"transactionMessageListener\") public TransactionSpringConsumer transactionSpringConsumer( TransactionMessageListener transactionMessageListener) &#123; return new TransactionSpringConsumer(\"transaction_consumer_group4\", Consts.MQ_ADDR, \"distributed_transaction_spring_topic\", transactionMessageListener); &#125;&#125; transactionMessageListener和userLocalTransactionListener这两个bean是被放入在Spring容器中，通过注解 Component 生成。正确的做法是直接在你想要调用的方法里直接传入对应的bean即可。 ——————————————————————————————-下面是错误的做法： 123456789101112131415161718192021@Configuration@ComponentScan(value = \"cn.loveyx815.rocketmq.mqtransaction.message\")public class MQConfig &#123;@Autowiredprivate UserLocalTransactionListener userLocalTransactionListener;@Autowiredprivate TransactionMessageListener transactionMessageListener; @Bean(name = \"prooducer\", initMethod = \"init\", destroyMethod = \"destory\") @DependsOn(value = \"userLocalTransactionListener\") public TransactionSpringProducer transactionSpringProducer() &#123; return new TransactionSpringProducer(\"transaction_spring_producer_group\", Consts.MQ_ADDR, 2, 5, 1000, userLocalTransactionListener); &#125; @Bean(name = \"consumer\", initMethod = \"init\", destroyMethod = \"destory\") @DependsOn(value = \"transactionMessageListener\") public TransactionSpringConsumer transactionSpringConsumer( ) &#123; return new TransactionSpringConsumer(\"transaction_consumer_group4\", Consts.MQ_ADDR, \"distributed_transaction_spring_topic\", transactionMessageListener); &#125;&#125; 与正确的不同的是下面的是自己在里面手动注入了这两个bean，去掉了方法参数。而结果得到的两个bean都为null","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.loveyx815.cn/tags/SpringBoot/"}]},{"title":"前端页面元素内容获取方式","slug":"summary/前端页面元素内容获取方式","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:14:24.703Z","comments":true,"path":"2020/04/19/summary/前端页面元素内容获取方式/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前端页面元素内容获取方式 主要列举val()，html()，innerHTML()的使用（也是方便自己回顾，刚开始用的少，没太注意区分） 1.val（）获取html元素的value值12345&lt;!-- js获取 --&gt;var v=$(\"#radio0\").val();&lt;!--html部分正文 --&gt;&lt;input type=\"radio\" id=\"radio0\" value=\"0\"&gt;男&lt;/input&gt;&lt;input type=\"radio\" id=\"radio1\" value=\"1\"&gt;女&lt;/input&gt; 点击并拖拽以移动 上面的v打印出来就是“0” 2.innerHTML() 与html( )的区别在一个 HTML 文档中, 我们可以使用 .html() 方法来获取任意一个元素的内容。 如果选择器匹配多于一个的元素，那么只有第一个匹配元素的 HTML 内容会被获取。innerHTML 是从对象的起始位置到终止位置的全部内容,包括Html标签。 innerHTML（）是js中的写法，html（）是jQuery中的写法。调用方法不一样，前者是xx.innerHTML = “table”，xx.html(“table”)两者实现功能大体相同，都是获取html标签元素内容，通常用来动态生成html页面代码和获取span标签的文本内容。 1234&lt;!--js部分 --&gt;var sv=$(\"#span1\").html();&lt;!--HTML部分 --&gt;&lt;span id=\"span1\"&gt;span文本&lt;/span&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.loveyx815.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.loveyx815.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://blog.loveyx815.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Java异常-受查与非受查","slug":"summary/Java异常","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T07:45:37.818Z","comments":true,"path":"2020/04/19/summary/Java异常/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/Java%E5%BC%82%E5%B8%B8/","excerpt":"","text":"Java异常-受查与非受查 在这里插入图片描述 所有的异常都是由Throwable继承而来，下级分为Error和Exception Error Error表示Java运行时系统的内部错误和资源耗尽错误，不应该抛出该类型的错误，只能通知用户，尽力安全关闭程序。 Exception 该分支派生出RuntimeException和其他异常（如I/O错误之类） 受查与非受查异常 非受查异常 派生于Error或RuntimeException类的所有异常 受查异常 其他所有的异常称为受查异常 一个方法必须声明所有可能抛出的受查异常，非受查异常要么不可控制（Error），要么就应该避免（RuntimeException）。当方法没有声明所有可能发生的受查异常，编译器会发出一个错误消息。 try-catch除了常用的try-catch-finally之外，还有一种带资源的try语句 若资源属于一个实现了AutoCloseable接口的类，该接口有个close方法 void close() throws Exception;整体的带资源的try语句可写成如下代码： 123try(Resource res = ...)&#123; do something;&#125; 当try语句退出或者发生异常时，会自动调用res.close()，相当于调用了finally","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"异常处理","slug":"异常处理","permalink":"http://blog.loveyx815.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"String、StringBuilder做为实参在方法中修改字符串值的问题","slug":"summary/String、StringBuilder做为实参在方法中修改字符串值的问题","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:07:45.254Z","comments":true,"path":"2020/04/19/summary/String、StringBuilder做为实参在方法中修改字符串值的问题/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/String%E3%80%81StringBuilder%E5%81%9A%E4%B8%BA%E5%AE%9E%E5%8F%82%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"String、StringBuilder做为实参在方法中修改字符串值的问题 场景介绍：需要在一个方法中同时修改两个字符串的值，因为不想传回一个数组，所以就尝试下直接修改字符串对象（地址引用） 下面介绍下几种修改方式： 12345678public static void changeString(String originStr)&#123; originStr=new String(\"str1 change\"); &#125; main()&#123; String str1=\"I am str1\"; changeString(str1); System.out.println(str1);//输出I am str1 &#125; 12345678public static void changeString(String originStr)&#123; originStr=\"str2 change\"; &#125; main()&#123; String str2=\"I am str2\"; changeString(str2); System.out.println(str2);//输出I am str2 &#125; 上面两种方式是直接传一个String对象，第一个是直接让形参指向新的对象，结果是方法内改变的值不是影响到实参；第二个是让形参指向一个字符串常量，结果同第一种是一样的。 因为在Java中，参数传递分为两种。一个是基本类型的值引用，这个就不多说了；还有个就是对象引用，而对象引用实际上是把存储在JVM栈区的对象引用的数据拷贝了一份。所以当你在方法内部将该对象拷贝的引用重新指向新的地址对实参是没有影响的。 这是引用拷贝时的示意图 在这里插入图片描述 接着拷贝后的originStr指向新的对象 在这里插入图片描述 可见str1的引用都没有改变，所以这样是不能改变String对象的。 接下来说所第二种为什么也不行，也就是在方法内部不重新为对象引用指向新的对象地址，而是直接给字符串赋值。先来看看String内部是怎么得构造的。 123456789101112public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ......&#125; String类是一个被final类，也就是它是不能被继承和更改的。里面用一个char数组维护他的字符，所以我们使用的字符串都是里面的char数组转化而来，而这个char[] value也是被final修饰过的。所以String对象具有不能被修改的属性。如下图： 在这里插入图片描述 即使你在方法内部使用的将一个String对象拷贝引用originStr指向一个字符串常量”new str1”，他也是拷贝引用去指向字符串常量池中某一块地址，所以依旧还是不能影响到实参的字符串对象值。 最后是使用了StringBuilder作为参数，在方法内部修改StringBuilder引用指向内存的数据，实现在方法中直接修改字符串的值。12345678public static void changeString(StringBuilder originStr)&#123; originStr.replace(0,originStr.length(),\"str1 change\");&#125; main()&#123;StringBuilder sb1=new StringBuilder(\"I am sb1\"); changeString(sb1); System.out.println(sb1);//输出str1 change &#125;","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"源码分析","slug":"源码分析","permalink":"http://blog.loveyx815.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"字符串","slug":"字符串","permalink":"http://blog.loveyx815.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"合并两个list元素错误分析","slug":"summary/合并list元素错误分析","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T08:59:22.587Z","comments":true,"path":"2020/04/19/summary/合并list元素错误分析/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/%E5%90%88%E5%B9%B6list%E5%85%83%E7%B4%A0%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/","excerpt":"","text":"合并两个list元素报错 背景：做题的时候需要合并连个list，本来直接用list.addAll()觉得没啥问题，结果当然会会报错。报错信息显示java.lang.UnsupportedOperationException不能操作异常。 问题已经知道，下面看看本质是啥吧！直接贴代码 12345List&lt;String&gt; list = Arrays.asList(list1); List&lt;String&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; strings = Arrays.asList(list2); int length1=list1.length; list.addAll(strings);//错误 这里的list1和list2是个String数组，这里要给两个数组并集起来。通过Arrays.asList可以把数组对象转换成List对象，但为什么后面在该被转换后的对象添加list对象却失败了。看下Arrays.asList源码 12345678910111213141516 public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125;//这里的ArrayList并不是java.util.ArrayList下面的,是java.util.Arrays下面的内部类//内部类部分实现如下private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; //…… &#125; 那么很明显了，这里维护了一个a这样的数组对象，他被修饰成final，所以后面再使用的时候该元素是不允许被修改的。回到问题本身，这时需要重新新建个可改变的List对象，所以得new java.util.ArraysList() 12345678//这里把字符串数据转化过来的list对象放入一个新建的ArrayList中List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(list1)) ; List&lt;String&gt; result = new ArrayList&lt;&gt;(); List&lt;String&gt; strings = Arrays.asList(list2); int length1=list1.length; // list.addAll(length1) list.addAll(strings);","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}]},{"title":"开发工作日常总结","slug":"summary/开发工作日常总结（命令、快捷键）","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-20T07:17:01.195Z","comments":true,"path":"2020/04/19/summary/开发工作日常总结（命令、快捷键）/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%EF%BC%88%E5%91%BD%E4%BB%A4%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%89/","excerpt":"","text":"开发工作日常总结IDE IDEA快捷键 key description note Ctrl + Shift + Enter 换行 Ctrl +X/Y 删除当前行 Ctrl +X本意为剪切，这里也可以子啊不选择中的状态下删除行 Linux 命令 描述 备注 tar -c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 解压总结 1、.tar 用 tar –xvf 解压 2、.gz 用 gzip -d或者gunzip 解压 3、.tar.gz和.tgz 用 tar –xzf 解压 4、.bz2 用 bzip2 -d或者用bunzip2 解压 5、.tar.bz2用tar –xjf 解压 6、.Z 用 uncompress 解压 7、.tar.Z 用tar –xZf 解压 8、.rar 用 unrar e解压 9、.zip 用 unzip 解压 SQLMAVEN打war包命令输入——-&gt; mvn install -DskipTests 或 mvn install -Dmaven.test.skip=true 打jar包命令输入——-&gt; mvn package -DskipTests 或 mvn package -Dmaven.test.skip=true JVM调优 参数 参数命令 作用 备注 -Xms 最小堆内存 -Xmx 最大堆内存 -Xmn 新生代分配的内存 -XX:+PrintGCDetails 打印GC日志 -XX:SurvivorRatio=8 新生代的Eden和survivor比例8：1 -XX:PretenureSizeThreshold 令大于这个设置的值得对象直接进入老年代 Serial、ParNew有效 jmap Java内存映像工具 jmap -dump:[live,]fromat=b,file=path pid 生成Java堆转储快照 jhat 堆转储快照分析工具 jhat path 分析dump文件，可以在浏览器查看分析结果（不推荐） jstack Java堆栈跟踪工具 jstack [option] pid option: -F -l -m,强制输出堆栈信息，显示关于锁的附加信息，显示native方法信息","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"快捷键","slug":"快捷键","permalink":"http://blog.loveyx815.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"常用命令","slug":"常用命令","permalink":"http://blog.loveyx815.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"maven项目pom.xml报错","slug":"summary/maven项目pom.xml报错","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:06:18.844Z","comments":true,"path":"2020/04/19/summary/maven项目pom.xml报错/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/summary/maven%E9%A1%B9%E7%9B%AEpom.xml%E6%8A%A5%E9%94%99/","excerpt":"","text":"maven项目pom.xml报错 expected START_TAG or END_TAG not TEXT (position: TEXT seen …\\ua0\\r\\n &lt;d… @60:11) less… (Ctrl+F1)Inspection info: Inspects a Maven model for resolution problems. 这种就是从别的地方复制粘贴的dependency时候有空格存在，导致文件识别不了，用IDE查找下空格的位置，删除就可以解决","categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"maven","slug":"maven","permalink":"http://blog.loveyx815.cn/tags/maven/"}]},{"title":"设计模式-策略模式","slug":"设计模式/设计模式-策略模式","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:08:45.185Z","comments":true,"path":"2020/04/19/设计模式/设计模式-策略模式/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式-策略模式 概念 策略模式（Strategy），定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换，可以针对不同业务选择不同逻辑的执行。 场景应用 有一笔订单需要对它进行流程管理。从订单产生-&gt;订单入库-&gt;配送-&gt;确认订单完成，有这样一个流程。这里有订单入库、配送这两个动作标签，在每个订单产生动作标签的时候，执行的不同的业务处理。这里用简单的分支语句来实现就是： 1234567if(action==\"订单入库\")｛ //执行业务代码｝else if(action==\"配送\")&#123; //执行业务代码&#125;...... 如果这里的分支有很多层，那么这块代码复杂度就会很高，而且也不容易维护。 下面使用策略模式实现。 策略模式实现 1. 抽象出业务处理器，可以当做分支结构中选择器。这个只是抽象出来的模型，后面需要给他具体实现。 12345678910111213141516public abstract class InspectionSolver &#123; /** * 业务代码抽象 * @param orderId * @param userId */ public abstract void solve(Long orderId, Long userId); /** * 策略标识，决定执行哪一个策略 * @return */ public abstract String[] supports();&#125;2. 根据抽象模型定义出自己的业务处理器，这就是实际的业务代码，当系统确定你要执行的业务后，就会执行相应的业务代码进行处理。 12345678910111213141516171819202122232425262728//继承抽象业务处理器并实现自己的业务处理，//可以根据supports中拥有的动作绑定相应的业务代码//订单批量转仓@Componentpublic class ChangeWarehouseSolver extends InspectionSolver &#123; @Override public void solve(Long orderId, Long userId) &#123; System.out.println(\"订单\"+orderId+\"开始进行批量转仓了。。\"); &#125; @Override public String[] supports() &#123; return new String[] &#123;InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE&#125;; &#125;&#125;//订单转换快递@Componentpublic class ChangeShippingSolver extends InspectionSolver &#123; @Override public void solve(Long orderId, Long userId) &#123; System.out.println(\"订单\"+orderId+\"开始进行转快递了。。\"); &#125; @Override public String[] supports() &#123; return new String[] &#123;InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_SHIPPING&#125;; &#125;&#125; 3. 现在策略是有了，所以还需要个调用的过程。想要根据不同的策略执行不同的逻辑业务，需要运用AOP切面得到当前所有具体的策略实现类。然后将对应的supports字段和对应的策略实现类存放在一个Map中。通过Map中的Key-Value就能知道对应的动作的策略，从而实现一个动态处理逻辑的过程。 123456789101112131415161718192021222324@Componentpublic class InspectionSolverChooser implements ApplicationContextAware &#123; private Map&lt;String, InspectionSolver&gt; chooseMap = new HashMap&lt;&gt;(); private ApplicationContext context; @PostConstruct public void register()&#123; System.out.println(\"执行PostConstruct...\"); Map&lt;String, InspectionSolver&gt; solverMap = context.getBeansOfType(InspectionSolver.class); for (InspectionSolver solver : solverMap.values()) &#123; for (String support : solver.supports()) &#123; chooseMap.put(support,solver); &#125; &#125; &#125; public InspectionSolver choose(String type)&#123; return chooseMap.get(type); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.context=applicationContext; System.out.println(\"applicationc初始化。。。\"); &#125;&#125; 这里通过实现ApplicationContextAware这个上下文接口，可以获取所有在Spring中托管的bean。前面的 ChangeWarehouseSolver 和 ChangeShippingSolver 两个策略实现类使用@Component注解过，让他们在Spring容器中注册过bean，solverMap 这个Map是用在存放获取Spring容器中的InspectionSolver bean，chooseMap 这个Map用来存放策略对应的业务。再通过choose(type) 这个方法调用，得到不同动作类型的策略，实现业务处理。 ==@PostConstruct==这里在说下@PostConstruct这个注解。当一个类中construct构造方法、@Autowired、@PostConstruct的执行优先级是construct&gt;Autowired&gt;PostConstruct。所以当我们想要使用@Autowired注入的bean的时候，使用构造函数肯定获取不到bean，那么可以把相应的操作放到@PostConstruct这个注解下使用。 4. 策略模式使用编写测试类 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes= Application.class)// 指定spring-boot的启动类public class InspectionTest &#123; @Autowired private InspectionSolverChooser chooser; @Test public void test() throws Exception&#123; //准备执行动作 转入仓库 String taskType = InspectionConstant.INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE; Long orderId = 12345L; Long userId = 123L; //获取任务类型对应的solver InspectionSolver solver = chooser.choose(taskType); if (solver == null) &#123; throw new RuntimeException(\"任务类型暂时无法处理!\"); &#125; //调用不同solver的方法进行处理 solver.solve(orderId,userId); &#125;&#125; 系统枚举类 12345public enum InspectionConstant &#123; public static String INSPECTION_TASK_TYPE_BATCH_CHANGE_WAREHOUSE=\"转入仓库\"; public static String INSPECTION_TASK_TYPE_BATCH_CHANGE_SHIPPING=\"开始配送\";&#125; 测试结果 在这里插入图片描述 这里执行的是转入仓库的业务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.loveyx815.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis缓存分页数据","slug":"缓存相关/Redis缓存分页数据","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:03:22.255Z","comments":true,"path":"2020/04/19/缓存相关/Redis缓存分页数据/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/Redis%E7%BC%93%E5%AD%98%E5%88%86%E9%A1%B5%E6%95%B0%E6%8D%AE/","excerpt":"","text":"用Redis缓存Web网页的分页数据 业务场景：把学生选课系统中学生群体数据放入缓存中，减少对数据库的访问，提高系统的负载能力。 实现思路：1.在用户首次登陆选课系统时，会先判断Redis缓存中是否有该缓存（这里使用的是Redis的zset数据结构来实现）。 补充：由于zset结构本身没有判断键是否存在的命令，我这里是用的是zcard(key)。zcard函数返回的是这个键对应的缓存集中的条数。 zset数据结构补充： Redis中存放数据都是将数据串行化放入内存中，所以将对象串行化有两种方式：流串行和JSON zadd(key,score,members) 向key的键下面添加元素，排序方式默认是以score的字典升序，score是double类型的值，不能传错了。这里的key可以认为是指定 的一个有序Set,通过zset的操作可以自动更新有序Set的排序 zset数据结构](https://img-blog.csdn.net/20180816180026172?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d1aXRhcmY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![点击并拖拽以移动 zrem(key,members) 当匹配到key缓存中有相同的members（字符串）时，就删除对应的记录 zrange(key,start,end) 获取索引区间的成员(按分数排序) 12341）[start,end]&#x3D;[0,-1] -1比表示最后一个元素的索引 zrange(key,0,-1)代表所有成员 2）end越界，显示从start开始到最后一个成员 3）start，end都越界，返回nil zcard(key) 获取key缓存中的所有元素的记录条数 zscore(key,members) 获取对应members的score并返回，若不存在则返回null zcard(key) 获取key缓存中的所有元素的记录 最后附上部分代码（有点糙，，） 页面初始化和分页： 123456789101112131415161718/* * 使用Redis有序SET进行缓存，可以进行排序 */ total = (long) redis.zcard(key); if(total&lt;=0)&#123;//如果元素个数《=0，表示key中没有缓存，从数据库中拿数据放入缓存》 list = service.findAllStudent(); redis.saveCache(\"student_rank\", list); //page = service.selectAllByPage(searchParams.getSearchMap(),pageRequest); &#125; int curruntindex=pageRequest.getPageNumber() * pageRequest.getPageSize();//分页开始索引 int endindex=curruntindex+pageRequest.getPageSize()-1;//分页结束索引 if(endindex&gt;total)&#123; endindex=total.intValue(); &#125; //total = (long) redis.zcard(key); sublist=redis.getPageCache(key,curruntindex,endindex); page = service.findAllByPageRedis( searchParams.getSearchMap(), pageRequest, sublist,total);//返回页面Bean 点击并拖拽以移动 对缓存更新数据： 1234567891011 /* * 对缓存更新操作 * 先删除匹配对的缓存中的数据，在新增数据 */ List&lt;Student&gt; student=findByStudentno(entity.getStudentno()); member=gson.toJson(student.get(0)); if (redis.zscore(key, member)!=null) &#123;//缓存中若没有member则返回null，否则返回 redis.zrem(key, member); //member对应的Double对象&#125; member=gson.toJson(entity); redis.zadd(key, Long.valueOf(entity.getStudentno()), member); 点击并拖拽以移动 现就到这了，后续再有想法再来更新","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.loveyx815.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.loveyx815.cn/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://blog.loveyx815.cn/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"设计模式-观察者模式","slug":"设计模式/设计模式-观察者模式","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T08:56:00.576Z","comments":true,"path":"2020/04/19/设计模式/设计模式-观察者模式/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式-观察者模式 观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新 1. 场景描述 通过气象站监测的数据，对外界进行公告展示。也就是气象站统计好数据后，确认修改完，公告那边也会收到改变后的数据。 2. 系统设计 首先定义两个接口，Subject主题和Observer观察者 123456//主题接口public interface Subject &#123; void registerObserver(Observer o); void removeObserver(Observer o); void notifyObservers();&#125; 1234//观察者接口public interface Observer &#123; void update(float temp , float humidity , float pressure);&#125; 这里的Subject是和Observer有关联的，因为需要在Subject的实现中去通知Observer Subject的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Auther: Yonggang Shi * @Date: 2020/04/17 17:27 * @Description: 主体实现发布通知对应观察者 */public class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidtiy; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; observers.remove(o); &#125; /** * 通过遍历当前已注册的观察者对象，实现数据通信，让观察者进行更新展示 * @param * @return void * @author shiyonggang * @creed: Talk is cheap,show me the code * @date 2020/4/18/018 下午 3:27 */ @Override public void notifyObservers() &#123; for (int i =0 ;i&lt;observers.size();i++)&#123; Observer observer = (Observer) observers.get(i); observer.update(temperature,humidtiy,pressure); &#125; &#125; public void measurementsChanged()&#123; notifyObservers(); &#125; public void setMeasurements(float temperature,float humidtiy,float pressure)&#123; this.temperature = temperature; this.humidtiy = humidtiy ; this.pressure = pressure; measurementsChanged(); &#125;&#125; 对成功加入Subject的观察者进行统一更新，收集数据通过setMeasurements 收集，最终把收集的数据再发送给所有观察者对象。 观察者具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Auther: Yonggang Shi * @Date: 2020/04/18 01:17 * @Description: 观察者具体实现 */public class CurrentConditionDisplay implements Observer,DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; /** * 通过构造函数的Subject对当前对象进行注册观察者操作 * @param weatherData Subject 主题对象 * @return * @author shiyonggang * @creed: Talk is cheap,show me the code * @date 2020/4/18/018 下午 3:35 */ public CurrentConditionDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; @Override public void display() &#123; System.out.println(\"Current conditions:\"+temperature+\"F degrees and \"+humidity+\"% humidity\"); &#125; /** * 在数据更新之后进行展示操作 * @param temp 温度 * @param humidity 湿度 * @param pressure 压力 * @return void * @author shiyonggang * @creed: Talk is cheap,show me the code * @date 2020/4/18/018 下午 3:37 */ @Override public void update(float temp, float humidity, float pressure) &#123; this.temperature = temp; this.humidity = humidity; display(); &#125;&#125; 这里的构造方法中引用了Subject的实现，这样是为了把当前这个观察者对象注册到对应的Subject中，也就是Observer的实现会依赖Subject。上面的Subject也有依赖Observer他的关系，通过接口的方式对两者依赖关系进行松耦合。 通过气象工作站进行收集更新 12345678910public class WeatherStation &#123; public static void main(String[] args)&#123; WeatherData weatherData =new WeatherData(); CurrentConditionDisplay currentConditionDisplay =new CurrentConditionDisplay(weatherData); weatherData.setMeasurements(11,12,13); &#125;&#125; 结果如下： 收集完数据之后，便通知了我们已注册进Subject的Observer。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Springboot中Redis学习（事务、Lua、跨域）","slug":"缓存相关/Springboot中Redis学习（事务、Lua、跨域）","date":"2020-04-18T16:00:00.000Z","updated":"2020-04-19T09:10:38.174Z","comments":true,"path":"2020/04/19/缓存相关/Springboot中Redis学习（事务、Lua、跨域）/","link":"","permalink":"http://blog.loveyx815.cn/2020/04/19/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/Springboot%E4%B8%ADRedis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81Lua%E3%80%81%E8%B7%A8%E5%9F%9F%EF%BC%89/","excerpt":"","text":"Redis事务Lua脚本 Lua脚本在Redis中具备原子性，可以保证数据一致性的高并发环境。 Spring中提供了RedisScript接口，DefaultRedisScript为他的实现类 RedisScript接口：12345678public interface RedisScript&lt;T&gt; &#123; //获得脚本的sha1 String getSha1(); //获取脚本的返回值 Class&lt;T&gt; getResultType(); //获取脚本的字符串 String getScriptAsString();&#125; 缓存注解应用1234567//获取ID，取参数ID缓存用户 @Override @Transactional @Cacheable(value = \" redisCache\",key = \"'redis_user_'+#id\") public User getUser(long id) &#123; return dao.getUser(id); &#125; @Cacheable 注解会先尝试从指定缓存中取值 12345678//插入用户，mybatis会回填ID，取结果ID缓存用户 @Override @Transactional @CachePut(value = \" redisCache\",key = \"'redis_user_'+#result.id\") public User insertUser(User user) &#123; dao.insertUser(user); return user; &#125; @CachePut 注解会把返回的结果放入缓存中注 AOP基于动态代理，这里同类内部调用方法，不会使注解生效 springboot中解决跨域问题 1@CrossOrigin(origins = &#123;\"对方的域名\", \"null\"&#125;) 将该注解加在对用的controller的类或者方法上就可以完成对跨域的访问代码Git地址https://github.com/rainandsunshine/springboot_reomte.git","categories":[{"name":"Redis,分布式","slug":"Redis-分布式","permalink":"http://blog.loveyx815.cn/categories/Redis-%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.loveyx815.cn/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.loveyx815.cn/tags/Redis/"}]}],"categories":[{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"框架系列","slug":"Java开发总结/框架系列","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/categories/Docker/"},{"name":"Redis,分布式","slug":"Redis-分布式","permalink":"http://blog.loveyx815.cn/categories/Redis-%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/categories/MQ/"},{"name":"JVM","slug":"Java开发总结/JVM","permalink":"http://blog.loveyx815.cn/categories/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/JVM/"},{"name":"前端","slug":"前端","permalink":"http://blog.loveyx815.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.loveyx815.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://blog.loveyx815.cn/tags/JUC/"},{"name":"并发","slug":"并发","permalink":"http://blog.loveyx815.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Java开发总结","slug":"Java开发总结","permalink":"http://blog.loveyx815.cn/tags/Java%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.loveyx815.cn/tags/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://blog.loveyx815.cn/tags/Mybatis/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.loveyx815.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"maven","slug":"maven","permalink":"http://blog.loveyx815.cn/tags/maven/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.loveyx815.cn/tags/Docker/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.loveyx815.cn/tags/Redis/"},{"name":"源码分析","slug":"源码分析","permalink":"http://blog.loveyx815.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"字符串","slug":"字符串","permalink":"http://blog.loveyx815.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.loveyx815.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.loveyx815.cn/tags/MQ/"},{"name":"分布式","slug":"分布式","permalink":"http://blog.loveyx815.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"JVM","slug":"JVM","permalink":"http://blog.loveyx815.cn/tags/JVM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.loveyx815.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://blog.loveyx815.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"异常处理","slug":"异常处理","permalink":"http://blog.loveyx815.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"快捷键","slug":"快捷键","permalink":"http://blog.loveyx815.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"常用命令","slug":"常用命令","permalink":"http://blog.loveyx815.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"缓存","slug":"缓存","permalink":"http://blog.loveyx815.cn/tags/%E7%BC%93%E5%AD%98/"}]}